/**
 * Advanced Caching System for Enterprise Performance
 * Suporta 1000+ usuários simultâneos
 */

'use client';

interface CacheEntry<T = any> {
  data: T;
  timestamp: number;
  ttl: number;
  hits: number;
  tags: string[];
}

interface CacheStats {
  hits: number;
  misses: number;
  evictions: number;
  size: number;
  memory: number;
}

class EnterpriseCache {
  private cache = new Map<string, CacheEntry>();
  private stats: CacheStats = {
    hits: 0,
    misses: 0,
    evictions: 0,
    size: 0,
    memory: 0
  };
  
  private maxSize: number = 10000; // Maximum cache entries
  private maxMemory: number = 512 * 1024 * 1024; // 512MB
  private cleanupInterval: NodeJS.Timeout | null = null;

  constructor() {
    // Start cleanup process
    this.startCleanup();
    
    // Monitor memory usage
    this.startMemoryMonitoring();
  }

  /**
   * Get item from cache
   */
  get<T = any>(key: string): T | null {
    const entry = this.cache.get(key);
    
    if (!entry) {
      this.stats.misses++;
      return null;
    }

    // Check if expired
    if (this.isExpired(entry)) {
      this.cache.delete(key);
      this.stats.misses++;
      this.stats.evictions++;
      return null;
    }

    // Update hit count and stats
    entry.hits++;
    this.stats.hits++;
    
    return entry.data as T;
  }

  /**
   * Set item in cache
   */
  set<T = any>(
    key: string, 
    data: T, 
    ttl: number = 5 * 60 * 1000, // 5 minutes default
    tags: string[] = []
  ): void {
    // Check memory limits
    if (this.shouldEvict()) {
      this.evictLRU();
    }

    const entry: CacheEntry<T> = {
      data,
      timestamp: Date.now(),
      ttl,
      hits: 0,
      tags
    };

    this.cache.set(key, entry);
    this.updateStats();
  }

  /**
   * Delete item from cache
   */
  delete(key: string): boolean {
    const deleted = this.cache.delete(key);
    if (deleted) {
      this.updateStats();
    }
    return deleted;
  }

  /**
   * Clear cache by tags
   */
  clearByTags(tags: string[]): number {
    let cleared = 0;
    
    for (const [key, entry] of this.cache.entries()) {
      if (entry.tags.some(tag => tags.includes(tag))) {
        this.cache.delete(key);
        cleared++;
      }
    }
    
    this.updateStats();
    return cleared;
  }

  /**
   * Clear all cache
   */
  clear(): void {
    this.cache.clear();
    this.stats.size = 0;
    this.stats.memory = 0;
  }

  /**
   * Get cache statistics
   */
  getStats(): CacheStats & { hitRate: number } {
    const total = this.stats.hits + this.stats.misses;
    const hitRate = total > 0 ? (this.stats.hits / total) * 100 : 0;
    
    return {
      ...this.stats,
      hitRate: Math.round(hitRate * 100) / 100
    };
  }

  /**
   * Warm up cache with important data
   */
  async warmUp(keys: string[]): Promise<void> {
    // Implementation for cache warming
    console.log(`Warming up cache with ${keys.length} keys`);
  }

  /**
   * Check if cache entry is expired
   */
  private isExpired(entry: CacheEntry): boolean {
    return Date.now() - entry.timestamp > entry.ttl;
  }

  /**
   * Check if cache should evict entries
   */
  private shouldEvict(): boolean {
    return this.cache.size >= this.maxSize || this.stats.memory >= this.maxMemory;
  }

  /**
   * Evict least recently used entries
   */
  private evictLRU(): void {
    // Sort by last access time and hit count
    const entries = Array.from(this.cache.entries())
      .sort(([, a], [, b]) => {
        // First sort by hits (ascending)
        if (a.hits !== b.hits) {
          return a.hits - b.hits;
        }
        // Then by timestamp (ascending - older first)
        return a.timestamp - b.timestamp;
      });

    // Remove 25% of entries
    const toRemove = Math.ceil(entries.length * 0.25);
    
    for (let i = 0; i < toRemove && i < entries.length; i++) {
      this.cache.delete(entries[i][0]);
      this.stats.evictions++;
    }

    this.updateStats();
  }

  /**
   * Update cache statistics
   */
  private updateStats(): void {
    this.stats.size = this.cache.size;
    
    // Estimate memory usage
    let memory = 0;
    for (const [key, entry] of this.cache.entries()) {
      memory += this.estimateSize(key) + this.estimateSize(entry);
    }
    this.stats.memory = memory;
  }

  /**
   * Estimate object size in bytes
   */
  private estimateSize(obj: any): number {
    const str = JSON.stringify(obj);
    return str.length * 2; // UTF-16 encoding
  }

  /**
   * Start periodic cleanup of expired entries
   */
  private startCleanup(): void {
    this.cleanupInterval = setInterval(() => {
      let cleaned = 0;
      
      for (const [key, entry] of this.cache.entries()) {
        if (this.isExpired(entry)) {
          this.cache.delete(key);
          cleaned++;
          this.stats.evictions++;
        }
      }
      
      if (cleaned > 0) {
        this.updateStats();
        console.log(`Cache cleanup: removed ${cleaned} expired entries`);
      }
    }, 60000); // Every minute
  }

  /**
   * Monitor memory usage
   */
  private startMemoryMonitoring(): void {
    setInterval(() => {
      const stats = this.getStats();
      
      // Log if memory usage is high
      if (stats.memory > this.maxMemory * 0.8) {
        console.warn(`Cache memory usage high: ${Math.round(stats.memory / 1024 / 1024)}MB`);
      }
      
      // Log cache performance
      if (stats.hitRate < 80 && (stats.hits + stats.misses) > 1000) {
        console.warn(`Cache hit rate low: ${stats.hitRate}%`);
      }
    }, 5 * 60 * 1000); // Every 5 minutes
  }

  /**
   * Destroy cache and cleanup
   */
  destroy(): void {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
    }
    this.clear();
  }
}

// Cache instances for different data types
export class CacheManager {
  private static instances = new Map<string, EnterpriseCache>();

  static getInstance(namespace: string = 'default'): EnterpriseCache {
    if (!this.instances.has(namespace)) {
      this.instances.set(namespace, new EnterpriseCache());
    }
    return this.instances.get(namespace)!;
  }

  static getMarketDataCache(): EnterpriseCache {
    return this.getInstance('market-data');
  }

  static getTradingSignalsCache(): EnterpriseCache {
    return this.getInstance('trading-signals');
  }

  static getUserDataCache(): EnterpriseCache {
    return this.getInstance('user-data');
  }

  static getDashboardCache(): EnterpriseCache {
    return this.getInstance('dashboard');
  }

  static getPortfolioCache(): EnterpriseCache {
    return this.getInstance('portfolio');
  }

  static getAllStats(): Record<string, any> {
    const stats: Record<string, any> = {};
    
    for (const [namespace, cache] of this.instances.entries()) {
      stats[namespace] = cache.getStats();
    }
    
    return stats;
  }

  static clearAll(): void {
    for (const cache of this.instances.values()) {
      cache.clear();
    }
  }

  static destroyAll(): void {
    for (const cache of this.instances.values()) {
      cache.destroy();
    }
    this.instances.clear();
  }
}

// React Hook for cache management
export function useCache(namespace: string = 'default') {
  const cache = CacheManager.getInstance(namespace);

  const get = <T = any>(key: string): T | null => {
    return cache.get<T>(key);
  };

  const set = <T = any>(
    key: string, 
    data: T, 
    ttl?: number, 
    tags?: string[]
  ): void => {
    cache.set(key, data, ttl, tags);
  };

  const remove = (key: string): boolean => {
    return cache.delete(key);
  };

  const clearByTags = (tags: string[]): number => {
    return cache.clearByTags(tags);
  };

  const stats = cache.getStats();

  return {
    get,
    set,
    remove,
    clearByTags,
    stats,
    cache
  };
}

// Cache decorators for API calls
export function cacheApi<T = any>(
  key: string,
  ttl: number = 5 * 60 * 1000, // 5 minutes
  tags: string[] = []
) {
  return function (
    target: any,
    propertyName: string,
    descriptor: PropertyDescriptor
  ) {
    const method = descriptor.value;
    const cache = CacheManager.getInstance('api');

    descriptor.value = async function (...args: any[]): Promise<T> {
      const cacheKey = `${key}:${JSON.stringify(args)}`;
      
      // Try cache first
      const cached = cache.get<T>(cacheKey);
      if (cached !== null) {
        return cached;
      }

      // Call original method
      const result = await method.apply(this, args);
      
      // Cache the result
      cache.set(cacheKey, result, ttl, tags);
      
      return result;
    };

    return descriptor;
  };
}

export default CacheManager;
